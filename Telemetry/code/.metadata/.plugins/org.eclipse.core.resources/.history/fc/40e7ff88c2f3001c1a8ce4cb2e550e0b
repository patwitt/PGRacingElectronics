/*
 * sensorFunctions.h
 *
 *  Created on: Jun 17, 2022
 *      Author: Patryk
 */

//INCLUDES

#include "sensorFunctions.h"


int initSensor(Sensor* sens,SensorTypes type){
	RTC_DateTypeDef date;
	HAL_RTC_GetDate(&hrtc, &date, RTC_FORMAT_BIN);
	sens->dataReady = 0;
	sens->type = type;
	int result = 0;
	switch(type)
	{
	case MLX:
		 result = mlxInit(&sens->sensor.mlx);
		 char path[20];
		 sprintf(path,"MLX%02d-%02d-%04d",date.Date,date.Month,date.Year);
		 strcpy(sens->path, "MLX.csv");
		 if(sens->sensor.mlx.ID == 1){

			 sens->File = (FIL*)malloc(sizeof(FIL));
			 mlxFile = sens->File;
		 }else
		 {
			 sens->File = mlxFile;
		 }

		break;
	case GYRO:
		break;
	}
	return result;
}
/* *******GYRO SECTION  ********/

//GYRO FUNCS

void imu_9dof_convert(struct imu_9dof * input, struct imu_9dof_calc * output)
{
	output->acc_data_calc[0] = (double) input->acc_data[0] / 16384;
	output->acc_data_calc[1] = (double) input->acc_data[1] / 16384;
	output->acc_data_calc[2] = (double) input->acc_data[2] / 16384;
	output->gyro_data_calc[0] = (double) input->gyro_data[0] * 250 / 32768;
	output->gyro_data_calc[1] = (double) input->gyro_data[1] * 250 / 32768;
	output->gyro_data_calc[2] = (double) input->gyro_data[2] * 250 / 32768;

}

void imu_9dof_get_data(struct imu_9dof * imu_9dof_data, struct imu_9dof_calc * imu_9dof_calculated)
{
    MPU9250_GetData(imu_9dof_data->acc_data, imu_9dof_data->mag_data, imu_9dof_data->gyro_data);
    imu_9dof_convert(imu_9dof_data, imu_9dof_calculated);
}


/* *******MLX90640 SECTION  ********/
FIL* mlxFile;
MLXSensor leftFWheelMLX;
MLXSensor rightFWheelMLX;
Sensor sensor;
//MLX FUNCS
int mlxInit(MLXSensor *mlx)
{
		static uint16_t eeMLX90640[832];
		static int ID = 1;

		HAL_Delay(200);
		MLX90640_SetRefreshRate(MLX90640_ADDR, RefreshRate);
	  	MLX90640_SetChessMode(MLX90640_ADDR);
	  	mlx->emissivity = 0.95;
	  	mlx->ID = ID;
	  	ID++;
	    int status = MLX90640_DumpEE(MLX90640_ADDR, eeMLX90640);
	    if (status != 0) return status;
	    status = MLX90640_ExtractParameters(eeMLX90640, &mlx->mlx90640);
	    if (status != 0) return status;

	    if(ID == 1)
	    {
	    	mlx->i2c = leftFrontWheelI2C;

	    }else if(ID == 2)
	    {
	    	mlx->i2c = rightFrontWheelI2C;

	    }

	    return 0;

}

//Copy and calcualte data from sensor memory to stm
int mlxGetData(MLXSensor mlx){
	uint16_t frame[832];
	int status = MLX90640_GetFrameData(MLX90640_ADDR, frame);
	if (status < 0)
	{
		if(DEBUG)
			printf("Error: %d\n",status);
		return status;
	}

	mlx.vdd = MLX90640_GetVdd(frame, &mlx.mlx90640);
	mlx.ambientTemp = MLX90640_GetTa(frame, &mlx.mlx90640) - TA_SHIFT;

	MLX90640_CalculateTo(frame, &mlx.mlx90640, mlx.emissivity , mlx.ambientTemp, mlx.data);
	status = MLX90640_GetFrameData(MLX90640_ADDR, frame);
	if(status < 0)
	{
		if(DEBUG)
			printf("Error: %d\n",status);
		return status;
	}
	MLX90640_CalculateTo(frame, &mlx.mlx90640, mlx.emissivity , mlx.ambientTemp, mlx.data);
	return 0;
}

//DEBUG printing on default uart
void mlxPrintData(MLXSensor mlx)
{
	for(int i = 0; i < 768; i++){
		if(i%32 == 0 && i != 0){
			printf("\r\n");
		}
		printf("%2.2f ",mlx.data[i]);
	}
}
