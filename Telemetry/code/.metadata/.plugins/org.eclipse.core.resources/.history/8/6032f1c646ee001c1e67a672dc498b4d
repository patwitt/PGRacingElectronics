/*
 * sensorFunctions.h
 *
 *  Created on: Jun 17, 2022
 *      Author: Patryk
 */

//INCLUDES

#include "sensorFunctions.h"

/* *******GYRO SECTION  ********/

//GYRO FUNCS

void imu_9dof_convert(struct imu_9dof * input, struct imu_9dof_calc * output)
{
	output->acc_data_calc[0] = (double) input->acc_data[0] / 16384;
	output->acc_data_calc[1] = (double) input->acc_data[1] / 16384;
	output->acc_data_calc[2] = (double) input->acc_data[2] / 16384;
	output->gyro_data_calc[0] = (double) input->gyro_data[0] * 250 / 32768;
	output->gyro_data_calc[1] = (double) input->gyro_data[1] * 250 / 32768;
	output->gyro_data_calc[2] = (double) input->gyro_data[2] * 250 / 32768;

}

void imu_9dof_get_data(struct imu_9dof * imu_9dof_data, struct imu_9dof_calc * imu_9dof_calculated)
{
    MPU9250_GetData(imu_9dof_data->acc_data, imu_9dof_data->mag_data, imu_9dof_data->gyro_data);
    imu_9dof_convert(imu_9dof_data, imu_9dof_calculated);
}


/* *******MLX90640 SECTION  ********/

//MLX FUNCS
int mlxInit(MLXSensor *mlx)
{
		static uint16_t eeMLX90640[832];
		static int ID = 1;

		HAL_Delay(200);
		MLX90640_SetRefreshRate(MLX90640_ADDR, RefreshRate);
	  	MLX90640_SetChessMode(MLX90640_ADDR);
	  	mlx->emissivity = 0.95;
	  	mlx->ID = ID;
	  	ID++;
	    int status = MLX90640_DumpEE(MLX90640_ADDR, eeMLX90640);
	    if (status != 0) return status;
	    status = MLX90640_ExtractParameters(eeMLX90640, &mlx->mlx90640);
	    if (status != 0) return status;
	    strcpy(mlx->path, "MLX.csv");
	    if(ID == 1)
	    {
	    	mlx->i2c = leftFrontWheelI2C;
	    	mlx->mlxFile = (FIL*)malloc(sizeof(FIL));
	    }else if(ID == 2)
	    {
	    	mlx->i2c = rightFrontWheelI2C;
	    	mlx->mlxFile = leftFWheelMLX.mlxFile;
	    }

	    return 0;

}

//Copy and calcualte data from sensor memory to stm
int mlxGetData(MLX mlx){
	uint16_t frame[832];
	int status = MLX90640_GetFrameData(MLX90640_ADDR, frame);
	if (status < 0)
	{
		if(DEBUG)
			printf("Error: %d\n",status);
		return status;
	}

	mlx.vdd = MLX90640_GetVdd(frame, &mlx.mlx90640);
	mlx.ambientTemp = MLX90640_GetTa(frame, &mlx.mlx90640) - TA_SHIFT;

	MLX90640_CalculateTo(frame, &mlx.mlx90640, mlx.emissivity , mlx.ambientTemp, mlx.data);
	status = MLX90640_GetFrameData(MLX90640_ADDR, frame);
	if(status < 0)
	{
		if(DEBUG)
			printf("Error: %d\n",status);
		return status;
	}
	MLX90640_CalculateTo(frame, &mlx.mlx90640, mlx.emissivity , mlx.ambientTemp, mlx.data);
	return 0;
}

//DEBUG printing on default uart
void mlxPrintData(MLX mlx)
{
	for(int i = 0; i < 768; i++){
		if(i%32 == 0 && i != 0){
			printf("\r\n");
		}
		printf("%2.2f ",mlx.data[i]);
	}
}
